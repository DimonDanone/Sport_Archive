/*
¬ы находитесь на вершине треугольной скалы, состо€щей из H уровней. Ќа верхнем уровне есть одна €чейка, на втором сверху уровне Ц две €чейки, на третьем сверху уровне уже три €чейки и так далее. — более верхних €чеек вы можете попасть на соседние снизу €чейки: €чейка вниз-налево и €чейка вниз-направо.
¬ каждой €чейке сидит либо детЄныш птеродактил€, либо взросла€ особь. ѕопадать в одну €чейку со взрослым птеродактилем категорически нельз€.
” каждого птеродактилЄнка есть степень сытости, выражаема€ целым неотрицательным числом. „ем больше его сытость, тем меньше он будет вас кусать и щипать, если вы окажетесь с ним в одной €чейке.
¬аша задача: спуститьс€ к подножию скалы, будучи наименее покусанным и пощипанным птеродактил€тами, и, разумеетс€, не съеденным взрослыми особ€ми. Ѕудем считать, что наиболее безопасному пути соответствует наибольша€ сумма сытостей птеродактил€т, мимо которых он пролегает.
¬ качестве ответа выведите сумму, соответствующую наиболее безопасному пути.
*/
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <map>
#include <iterator>

using namespace std;

vector<vector<int>> g;
vector<vector<int>> res;

int main()
{
	int h; cin >> h;

	g.resize(h);
	res.resize(h);

	int k = 1;

	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < k; j++)
		{
			int a; cin >> a;

			g[i].push_back(a);
			res[i].push_back(0);
		}

		k++;
	}

	for (int i = 0; i < g[h - 1].size(); i++)
		res[h - 1][i] = g[h - 1][i];

	for (int i = h - 2; i >= 0; i--)
	{
		for (int j = 0; j < g[i].size(); j++)
		{
			if (g[i][j] != -1)
			{
				bool ok = false;

				if (res[i + 1][j + 1] != -1)
				{
					res[i][j] = max(res[i][j], res[i + 1][j + 1] + g[i][j]);
					ok = true;
				}
				else
					res[i][j] = -1;

				if (res[i + 1][j] != -1)
					res[i][j] = max(res[i][j], res[i + 1][j] + g[i][j]);
				else if (!ok)
					res[i][j] = -1;
			}
			else
				res[i][j] = -1;
		}
	}

	cout << res[0][0];
}
/*
3 0 -1 0 -1 -1 0
0
-1 0
-1 0 -1
*/