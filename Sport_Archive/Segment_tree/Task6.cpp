/*
У начинающего программиста Ксюши есть последовательность a, состоящая из 2n неотрицательных целых чисел: a1,?a2,?...,?a2n. Сейчас Ксюша изучает битовые операции. Чтобы лучше понять как они работают, Ксюша решила подсчитать некоторое значение v по a.

А именно, значение v считается в несколько итераций. На первой итерации, Ксюша записывает новую последовательность a1 or a2,?a3 or a4,?...,?a2n?-?1 or a2n, состоящую из 2n?-?1 элементов. Другими словами, она записывает побитовое ИЛИ соседних элементов последовательности a. На второй итерации, Ксюша записывает побитовое исключающее ИЛИ соседних элементов полученной после первой итерации последовательности. На третьей итерации Ксюша записывает побитовое ИЛИ соседних элементов последовательности, полученной после второй итерации. И так далее операции побитовое исключающее ИЛИ и побитовое ИЛИ чередуются. В конце концов получится последовательность, состоящая из одного элемента, этот элемент и равен v.

Рассмотрим пример, пусть последовательность a?=?(1,?2,?3,?4). Тогда запишем все преобразования (1,?2,?3,?4) ?>? (1 or 2?=?3,?3 or 4?=?7) ?>? (3 xor 7?=?4), в итоге v?=?4.

Вам задана изначальная последовательность Ксюши. Но посчитать значение v по заданной последовательности было бы слишком просто, поэтому Вам дополнительно заданы m запросов. Каждый запрос — это пара целых чисел p,?b. Запрос p,?b означает, что нужно выполнить присвоение ap?=?b. После каждого запроса, нужно вывести новое значение v посчитанное по новой последовательности a.
*/
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;

const int NMAX = 100000;
long long r, n, sz;
vector<int> tree(4 * NMAX);

void built(vector<long long> &a)
{
	sz = 1;
	while (sz < r)
	{
		sz *= 2;
	}

	for (int i = 0; i < r; i++)
		tree[i + sz] = a[i];

	int s = sz/2;
	bool k = true;

	for (int i = sz - 1; i > 0; i--)
	{
		if (i < s)
		{
			s /= 2;
			k = !k;
		}
		if (k)
			tree[i] = tree[2 * i] | tree[2 * i + 1];
		else
			tree[i] = tree[2 * i] ^ tree[2 * i + 1];
	}
}

void upd(int p, int b)
{ 
	p += sz;

	bool k = true;

	for (tree[p] = b; p > 1; p /= 2)
	{
		if (k)
			tree[p / 2] = tree[p] | tree[p ^ 1];
		else
			tree[p / 2] = tree[p] ^ tree[p ^ 1];
		k = !k;
	}
}

void pr()
{
	for (int i = 0; i < 40; i++)
		cout << tree[i] << " ";
	cout << endl;
}


int main()
{
	cin >> n;
	r = pow(2, n);
	vector<long long> a(r);

	int m;
	cin >> m;

	for (long long i = 0; i < r; i++)
	{
		cin >> a[i];
	}

	built(a);

	for (int i = 0; i < m; i++)  
	{
		long long p, b;
		cin >> p >> b;
		upd(--p, b);
		cout << tree[1] << endl;
	}

}
/* Sun Jan 27 2019 17:11:59 GMT+0300 (MSK) */
