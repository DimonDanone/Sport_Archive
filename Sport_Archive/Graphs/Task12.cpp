/*
Славный король Уго II объявил войну. Священную, победоносную, малокровную, но разрушительную!
Сразу же после объявления войны король начал собирать армию — он решил отправить всем своим непосредственным вассалам приказ о наборе рекрутов. Те, в свою очередь, перешлют приказ своим вассалам, и так далее. Таким образом, даже самый захудалый из дворян королевства окажется вовлечён в подготовку к войне.
Как только дворянин, не имеющий вассалов, получает приказ, он тут же начинает сбор войск и выступает в поход через несколько дней. Если же у дворянина есть вассалы, он ждёт, пока под его знамёнами не окажутся войска по крайней мере x% из его непосредственных вассалов, затем собирает свои собственные войска и тоже выступает в поход. Славный король Уго II отправится воевать, как только к войне будут готовы хотя бы x% его непосредственных вассалов.
Число x Уго II указывает в своём приказе о наборе рекрутов. Для успешной кампании королю необходимо собрать как можно больше воинов. С другой стороны, если собирать войска дольше t дней, неприятель может пронюхать о готовящемся вторжении и нанести удар первым! Помогите Уго II найти максимально возможное значение числа x.
*/
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <string>
#include <map>
#include <queue>

using  namespace std;

vector<vector<int>> g;
vector<int> time_v;
double x;

double eps = 1e-7;

int dfs(int pos)
{
    int res = time_v[pos];

    vector<int> v;

    for (int i = 0; i < g[pos].size(); i++)
    {
        int to = g[pos][i];

        v.push_back(dfs(to));
    }

    sort(v.begin(), v.end());

    if (!v.empty() && int(x * v.size()) >= 0)
    {
        res += v[int(x * v.size())];
        /*for (int i = 0; i < int(x * v.size() + 0.5); i++)
        {
            res += v[i];
        }*/
    }

    return res;
}

int main()
{
    int n, t; cin >> n >> t;

    g.resize(n);
    time_v.resize(n);

    for (int i = 1; i < n; i++)
    {
        int pr, ti; cin >> pr >> ti;
        pr--;
        g[pr].push_back(i);
        time_v[i] = ti;
    }

    double l = 0, r = 1;

    while (r - l > eps)
    {
        double mid = (l + r)/2;
        x = mid;

        int res = dfs(0);
       // cout << mid << " " << res << endl;
        if (res <= t)
        {
            l = mid;
        }
        else
        {
            r = mid;
        }
    }

    cout.precision(5);
   // l += 0.000005;

    cout << fixed << l*100 << endl;
}